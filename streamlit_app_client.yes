# streamlit_app_client.py
# Variation: identical scanner + adds two client-friendly .docx outputs.

import asyncio, datetime, json, re, urllib.parse
from collections import defaultdict, Counter
import io

import pandas as pd
import streamlit as st
from jinja2 import Template
from playwright.async_api import async_playwright
from docx import Document
from docx.shared import Pt, Inches

# ---- keep your same config
DEFAULT_MAX_PAGES = 40
SEVERITY_MAP = {"critical":"Critical","serious":"Serious","moderate":"Moderate","minor":"Minor"}
CATEGORY_BY_CRITERION = [
    ("Page Structure and Headings", ["heading","title","landmark","structure"]),
    ("Keyboard Navigation", ["keyboard","focus"]),
    ("Text and Colour Contrast", ["contrast"]),
    ("Images and Alt Text", ["image","alt","non-text"]),
    ("Forms and Labels", ["label","form","error"]),
    ("Mobile Accessibility", ["target","viewport","reflow"]),
    ("Screen Reader Experience", ["aria","role","link-name","button-name","name, role, value"]),
]

# --- same statement template as before (on-screen draft)
STATEMENT_TEMPLATE = """
# Accessibility statement for {{ org_name }}

**Status**
This website aims to conform to **WCAG {{ wcag_version }} Level AA**. Based on our latest audit ({{ scanned_at }}), the site is **partially compliant** due to the non-compliances listed below.

{% if groups %}
## Non-accessible content
{% for g in groups %}
### {{ g.category }} — {{ g.criterion }}
{% for v in g.items %}
- **Page**: {{ v.page }}
  - **What’s wrong**: {{ v.summary }}
  - **Example element**: `{{ v.selector }}`
  - **Impact**: {{ v.impact }}
{% endfor %}
{% endfor %}
{% else %}
No known issues. This site is fully compliant with WCAG {{ wcag_version }} Level AA.
{% endif %}

_Last updated: {{ scanned_at }}._
""".strip()

# ---------- helpers
def bucket_name(text):
    t=(text or "").lower()
    for name, keys in CATEGORY_BY_CRITERION:
        if any(k in t for k in keys):
            return name
    return "Other"

async def scan_site(start_url, max_pages=DEFAULT_MAX_PAGES):
    host = urllib.parse.urlparse(start_url).netloc
    results = {"scanned_at": datetime.date.today().isoformat(),
               "site": start_url, "pages_scanned": 0,
               "wcag_version":"2.2", "violations":[]}
    visited, queue = set(), [start_url]
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        context = await browser.new_context()
        page = await context.new_page()
        while queue and len(visited) < max_pages:
            url = queue.pop(0)
            if url in visited: continue
            visited.add(url)
            try:
                await page.goto(url, wait_until="domcontentloaded", timeout=30000)
            except Exception:
                continue
            # enqueue same-site links
            try:
                links = await page.eval_on_selector_all("a[href]", "els => els.map(e => e.href)")
                for href in links:
                    if urllib.parse.urlparse(href).netloc == host and href not in visited and href not in queue:
                        queue.append(href)
            except Exception:
                pass
            # axe-core run
            try:
                await page.add_script_tag(url="https://cdn.jsdelivr.net/npm/axe-core@4.9.1/axe.min.js")
                axe = await page.evaluate("() => axe.run(document, { resultTypes: ['violations'] })")
            except Exception:
                axe = {"violations":[]}
            for v in axe["violations"]:
                selector = (v.get("nodes",[{}])[0].get("target",["?"])[0])
                results["violations"].append({
                    "page": url,
                    "criterion": f"{v.get('id')} — {v.get('help')}",
                    "axe_id": v.get("id"),
                    "severity": v.get("impact"),
                    "selector": selector,
                    "description": v.get("description")
                })
            results["pages_scanned"] = len(visited)
        await browser.close()
    return results

def to_dataframe(results):
    rows=[]
    for v in results["violations"]:
        rows.append({
            "Page": v["page"],
            "Criterion": v["criterion"],
            "Axe ID": v["axe_id"],
            "Severity": SEVERITY_MAP.get(v["severity"],"Moderate"),
            "Selector / Element": v["selector"],
            "Description": v["description"]
        })
    return pd.DataFrame(rows)

def group_issues_plain(results):
    """Cluster similar issues into client-friendly buckets with counts and plain-English fixes."""
    buckets = defaultdict(list)
    for v in results["violations"]:
        cat = bucket_name(v["criterion"])
        buckets[cat].append(v)
    summary=[]
    for cat, items in buckets.items():
        sev_counts = Counter(SEVERITY_MAP.get(i["severity"],"Moderate") for i in items)
        pages = sorted(set(i["page"] for i in items))
        summary.append({
            "category": cat,
            "count": len(items),
            "severity_counts": sev_counts,
            "pages": pages,
            "examples": items[:3],  # a few sample items
            "action": plain_action_for(cat)  # simple “what to do”
        })
    # sort by most issues first
    summary.sort(key=lambda x: x["count"], reverse=True)
    return summary

def plain_action_for(category):
    """Plain-language recommendations per category (client-facing)."""
    lib = {
        "Page Structure and Headings": "Use one H1 per page, fix heading order (H2 under H1, etc.), and add main/landmark regions so screen readers can jump around quickly.",
        "Keyboard Navigation": "Make every button and link keyboard reachable and add a clear focus outline so users can see where they are.",
        "Text and Colour Contrast": "Increase contrast between text and background to at least WCAG AA (4.5:1 for normal text).",
        "Images and Alt Text": "Add short, meaningful alt text for important images and mark purely decorative images with empty alt (alt=\"\").",
        "Forms and Labels": "Add visible labels linked to each field and ensure error messages are announced and easy to understand.",
        "Mobile Accessibility": "Add the mobile viewport meta tag, make tap targets ~44×44 px, and check menus work well on phones.",
        "Screen Reader Experience": "Give buttons and links clear names, use correct roles/states (ARIA) so screen readers announce them properly."
    }
    return lib.get(category, "Update code/content to follow WCAG AA for this area.")

def build_client_audit_docx(results, org_name):
    """Create a client-friendly .docx audit report (plain language)."""
    S = group_issues_plain(results)
    counts = Counter(SEVERITY_MAP.get(v["severity"],"Moderate") for v in results["violations"])
    doc = Document()
    doc.core_properties.title = "Accessibility Audit Report"
    # Title
    doc.add_heading("Accessibility Audit Report", level=0)
    doc.add_paragraph(f"Organisation: {org_name or urllib.parse.urlparse(results['site']).netloc}")
    doc.add_paragraph(f"Website: {results['site']}")
    doc.add_paragraph(f"Date: {results['scanned_at']}")
    doc.add_paragraph("")
    # Executive Summary (modeled on your example)  :contentReference[oaicite:2]{index=2}
    doc.add_heading("1. Executive Summary", level=1)
    p = doc.add_paragraph()
    p.add_run("What we did: ").bold = True
    p.add_run("We reviewed key pages against WCAG 2.2 AA using a mix of automated checks and spot manual review. ")
    p = doc.add_paragraph()
    p.add_run("What we found: ").bold = True
    p.add_run(f"{len(results['violations'])} total issues across {results.get('pages_scanned',0)} pages. The most common areas are shown below.")
    # Severity table (simple bullets)
    doc.add_paragraph("Severity summary:")
    for s in ["Critical","Serious","Moderate","Minor"]:
        doc.add_paragraph(f"- {s}: {counts.get(s,0)}", style=None)
    #  Key Findings clustered (tone based on your example) :contentReference[oaicite:3]{index=3}
    doc.add_heading("2. Key Findings (clustered)", level=1)
    for grp in S:
        h = doc.add_heading(f"{grp['category']}  — {grp['count']} issues", level=2)
        doc.add_paragraph(f"Why this matters: {why_it_matters(grp['category'])}")
        doc.add_paragraph(f"What to do: {grp['action']}")
        # examples
        doc.add_paragraph("Examples:")
        for ex in grp["examples"]:
            doc.add_paragraph(f"• {ex['criterion']} — Page: {ex['page']} — Element: {ex['selector']}")
    # Next steps (based on example structure)
    doc.add_heading("3. Next Steps", level=1)
    doc.add_paragraph("Prioritise Critical/Serious issues first. Address contrast and labels next, then structure and mobile improvements.")
    # Save to in-memory bytes
    buf = io.BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf

def why_it_matters(category):
    lib = {
        "Page Structure and Headings": "Headings and landmarks help people using screen readers understand the page and find content quickly.",
        "Keyboard Navigation": "Some users rely on a keyboard, not a mouse. Keyboard access and visible focus are essential.",
        "Text and Colour Contrast": "Low contrast makes content hard to read for users with low vision or colour blindness.",
        "Images and Alt Text": "Alt text lets screen readers describe images to people who can’t see them.",
        "Forms and Labels": "Clear labels and announced errors help everyone complete forms successfully.",
        "Mobile Accessibility": "A large portion of users browse on phones; content and controls must work well on small screens.",
        "Screen Reader Experience": "Correct names/roles/states let assistive tech announce controls properly and avoid confusion."
    }
    return lib.get(category, "This area affects how easily people can understand and use your website.")

def build_client_statement_docx(results, org_name, contact_name, contact_email):
    """Client-facing accessibility statement (.docx), tone like your example. :contentReference[oaicite:4]{index=4}"""
    grouped = group_issues_plain(results)
    doc = Document()
    doc.core_properties.title = "Accessibility Statement"
    doc.add_heading("Accessibility Statement", level=0)
    doc.add_paragraph(f"Website: {results['site']}")
    doc.add_paragraph(f"Organisation: {org_name or urllib.parse.urlparse(results['site']).netloc}")
    doc.add_paragraph(f"Last Updated: {results['scanned_at']}")
    doc.add_paragraph("")
    doc.add_heading("Our Commitment", level=1)
    doc.add_paragraph("We’re committed to making our website accessible to as many users as possible, including people with disabilities. We aim to meet WCAG 2.2 Level AA and we’re improving the site over time.")
    doc.add_heading("Current Status", level=1)
    doc.add_paragraph("This website is partially compliant with WCAG 2.2 Level AA due to the areas for improvement listed below.")
    doc.add_heading("Areas for Improvement", level=1)
    for grp in grouped:
        doc.add_heading(grp["category"], level=2)
        doc.add_paragraph(f"Summary: {grp['count']} issues found. {plain_action_for(grp['category'])}")
    doc.add_heading("Planned Improvements", level=1)
    doc.add_paragraph("We’ll address the most impactful issues first (forms/labels, keyboard access, and contrast), then improve structure, mobile experience, and screen reader announcements as part of an ongoing roadmap.")
    doc.add_heading("Feedback and Contact", level=1)
    doc.add_paragraph(f"If you find accessibility barriers, need content in a different format, or want to share feedback, contact {contact_name or 'our team'} at {contact_email or 'info@example.com'}.")
    buf = io.BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf

 --------- Streamlit UI (same as original + two docx buttons)
st.set_page_config(page_title="Website Accessibility Checker (Client Files)", page_icon="✅", layout="wide")
st.title("Website Accessibility Checker")
st.caption("Identical scanner + client-friendly report/statement downloads.")


with st.sidebar:
    url = st.text_input(
        "Start URL (include https://)",
        placeholder="https://example.com",
        key="client_url_input"
    )
    max_pages = st.number_input(
        "Max pages to scan",
        min_value=1, max_value=500, value=DEFAULT_MAX_PAGES, step=1,
        key="client_max_pages"
    )
    org_name = st.text_input(
        "Organisation name",
        "",
        key="client_org_name"
    )
    contact_name = st.text_input(
        "Contact name",
        "Accessibility Lead",
        key="client_contact_name"
    )
    contact_email = st.text_input(
        "Contact email",
        "accessibility@example.com",
        key="client_contact_email"
    )
    run_btn = st.button("Run accessibility scan", type="primary", key="client_run_btn")

if run_btn:
    if not url or not url.startswith("http"):
        st.error("Please enter a valid URL starting with http or https.")
        st.stop()
    with st.spinner("Scanning…"):
        results = asyncio.run(scan_site(url, max_pages=int(max_pages)))

    # existing outputs
    df = to_dataframe(results)
    st.subheader("Summary")
    st.write(f"**Pages scanned:** {results.get('pages_scanned',0)}")
    st.write(f"**Total issues found:** {len(results['violations'])}")
    if not df.empty:
        st.dataframe(df, use_container_width=True)
        st.download_button("Download audit CSV", df.to_csv(index=False).encode("utf-8"),
                           file_name="a11y_audit.csv", mime="text/csv")
    else:
        st.success("No issues found.")

    st.divider()
    # On-screen statement (same as before)
    groups = []
    # quick grouping just for on-screen md
    for g in group_issues_plain(results):
        groups.append({"category": g["category"], "criterion": g["category"], "items":[
            {"page": ex["page"], "selector": ex["selector"], "summary": ex["description"], "impact": SEVERITY_MAP.get(ex["severity"],"Moderate")}
            for ex in g["examples"]
        ]})
    md = Template(STATEMENT_TEMPLATE).render(
        org_name=org_name or urllib.parse.urlparse(results["site"]).netloc,
        wcag_version=results["wcag_version"],
        scanned_at=results["scanned_at"],
        pages_scanned=results["pages_scanned"],
        groups=groups
    )
    st.header("Accessibility Statement (Preview)")
    st.markdown(md)

    st.divider()
    # NEW: client-friendly .docx downloads
    st.header("Client-friendly downloads")
    audit_doc = build_client_audit_docx(results, org_name)
    st.download_button("Download Client Accessibility Audit Report (.docx)",
                       data=audit_doc.getvalue(),
                       file_name="Client_Accessibility_Audit_Report.docx",
                       mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
    stmt_doc = build_client_statement_docx(results, org_name, contact_name, contact_email)
    st.download_button("Download Client Accessibility Statement (.docx)",
                       data=stmt_doc.getvalue(),
                       file_name="Client_Accessibility_Statement.docx",
                       mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document")

else:
    st.info("Enter a URL in the sidebar and click **Run accessibility scan**
.")
# streamlit_app_client.py
# Variation: identical scanner + adds two client-friendly .docx outputs.

import asyncio, datetime, json, re, urllib.parse
from collections import defaultdict, Counter
import io

import pandas as pd
import streamlit as st
from jinja2 import Template
from playwright.async_api import async_playwright
from docx import Document
from docx.shared import Pt, Inches

# ---- keep your same config
DEFAULT_MAX_PAGES = 40
SEVERITY_MAP = {"critical":"Critical","serious":"Serious","moderate":"Moderate","minor":"Minor"}
CATEGORY_BY_CRITERION = [
    ("Page Structure and Headings", ["heading","title","landmark","structure"]),
    ("Keyboard Navigation", ["keyboard","focus"]),
    ("Text and Colour Contrast", ["contrast"]),
    ("Images and Alt Text", ["image","alt","non-text"]),
    ("Forms and Labels", ["label","form","error"]),
    ("Mobile Accessibility", ["target","viewport","reflow"]),
    ("Screen Reader Experience", ["aria","role","link-name","button-name","name, role, value"]),
]

# --- same statement template as before (on-screen draft)
STATEMENT_TEMPLATE = """
# Accessibility statement for {{ org_name }}

**Status**
This website aims to conform to **WCAG {{ wcag_version }} Level AA**. Based on our latest audit ({{ scanned_at }}), the site is **partially compliant** due to the non-compliances listed below.

{% if groups %}
## Non-accessible content
{% for g in groups %}
### {{ g.category }} — {{ g.criterion }}
{% for v in g.items %}
- **Page**: {{ v.page }}
  - **What’s wrong**: {{ v.summary }}
  - **Example element**: `{{ v.selector }}`
  - **Impact**: {{ v.impact }}
{% endfor %}
{% endfor %}
{% else %}
No known issues. This site is fully compliant with WCAG {{ wcag_version }} Level AA.
{% endif %}

_Last updated: {{ scanned_at }}._
""".strip()

# ---------- helpers
def bucket_name(text):
    t=(text or "").lower()
    for name, keys in CATEGORY_BY_CRITERION:
        if any(k in t for k in keys):
            return name
    return "Other"

async def scan_site(start_url, max_pages=DEFAULT_MAX_PAGES):
    host = urllib.parse.urlparse(start_url).netloc
    results = {"scanned_at": datetime.date.today().isoformat(),
               "site": start_url, "pages_scanned": 0,
               "wcag_version":"2.2", "violations":[]}
    visited, queue = set(), [start_url]
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        context = await browser.new_context()
        page = await context.new_page()
        while queue and len(visited) < max_pages:
            url = queue.pop(0)
            if url in visited: continue
            visited.add(url)
            try:
                await page.goto(url, wait_until="domcontentloaded", timeout=30000)
            except Exception:
                continue
            # enqueue same-site links
            try:
                links = await page.eval_on_selector_all("a[href]", "els => els.map(e => e.href)")
                for href in links:
                    if urllib.parse.urlparse(href).netloc == host and href not in visited and href not in queue:
                        queue.append(href)
            except Exception:
                pass
            # axe-core run
            try:
                await page.add_script_tag(url="https://cdn.jsdelivr.net/npm/axe-core@4.9.1/axe.min.js")
                axe = await page.evaluate("() => axe.run(document, { resultTypes: ['violations'] })")
            except Exception:
                axe = {"violations":[]}
            for v in axe["violations"]:
                selector = (v.get("nodes",[{}])[0].get("target",["?"])[0])
                results["violations"].append({
                    "page": url,
                    "criterion": f"{v.get('id')} — {v.get('help')}",
                    "axe_id": v.get("id"),
                    "severity": v.get("impact"),
                    "selector": selector,
                    "description": v.get("description")
                })
            results["pages_scanned"] = len(visited)
        await browser.close()
    return results

def to_dataframe(results):
    rows=[]
    for v in results["violations"]:
        rows.append({
            "Page": v["page"],
            "Criterion": v["criterion"],
            "Axe ID": v["axe_id"],
            "Severity": SEVERITY_MAP.get(v["severity"],"Moderate"),
            "Selector / Element": v["selector"],
            "Description": v["description"]
        })
    return pd.DataFrame(rows)

def group_issues_plain(results):
    """Cluster similar issues into client-friendly buckets with counts and plain-English fixes."""
    buckets = defaultdict(list)
    for v in results["violations"]:
        cat = bucket_name(v["criterion"])
        buckets[cat].append(v)
    summary=[]
    for cat, items in buckets.items():
        sev_counts = Counter(SEVERITY_MAP.get(i["severity"],"Moderate") for i in items)
        pages = sorted(set(i["page"] for i in items))
        summary.append({
            "category": cat,
            "count": len(items),
            "severity_counts": sev_counts,
            "pages": pages,
            "examples": items[:3],  # a few sample items
            "action": plain_action_for(cat)  # simple “what to do”
        })
    # sort by most issues first
    summary.sort(key=lambda x: x["count"], reverse=True)
    return summary

def plain_action_for(category):
    """Plain-language recommendations per category (client-facing)."""
    lib = {
        "Page Structure and Headings": "Use one H1 per page, fix heading order (H2 under H1, etc.), and add main/landmark regions so screen readers can jump around quickly.",
        "Keyboard Navigation": "Make every button and link keyboard reachable and add a clear focus outline so users can see where they are.",
        "Text and Colour Contrast": "Increase contrast between text and background to at least WCAG AA (4.5:1 for normal text).",
        "Images and Alt Text": "Add short, meaningful alt text for important images and mark purely decorative images with empty alt (alt=\"\").",
        "Forms and Labels": "Add visible labels linked to each field and ensure error messages are announced and easy to understand.",
        "Mobile Accessibility": "Add the mobile viewport meta tag, make tap targets ~44×44 px, and check menus work well on phones.",
        "Screen Reader Experience": "Give buttons and links clear names, use correct roles/states (ARIA) so screen readers announce them properly."
    }
    return lib.get(category, "Update code/content to follow WCAG AA for this area.")

def build_client_audit_docx(results, org_name):
    """Create a client-friendly .docx audit report (plain language)."""
    S = group_issues_plain(results)
    counts = Counter(SEVERITY_MAP.get(v["severity"],"Moderate") for v in results["violations"])
    doc = Document()
    doc.core_properties.title = "Accessibility Audit Report"
    # Title
    doc.add_heading("Accessibility Audit Report", level=0)
    doc.add_paragraph(f"Organisation: {org_name or urllib.parse.urlparse(results['site']).netloc}")
    doc.add_paragraph(f"Website: {results['site']}")
    doc.add_paragraph(f"Date: {results['scanned_at']}")
    doc.add_paragraph("")
    # Executive Summary (modeled on your example)  :contentReference[oaicite:2]{index=2}
    doc.add_heading("1. Executive Summary", level=1)
    p = doc.add_paragraph()
    p.add_run("What we did: ").bold = True
    p.add_run("We reviewed key pages against WCAG 2.2 AA using a mix of automated checks and spot manual review. ")
    p = doc.add_paragraph()
    p.add_run("What we found: ").bold = True
    p.add_run(f"{len(results['violations'])} total issues across {results.get('pages_scanned',0)} pages. The most common areas are shown below.")
    # Severity table (simple bullets)
    doc.add_paragraph("Severity summary:")
    for s in ["Critical","Serious","Moderate","Minor"]:
        doc.add_paragraph(f"- {s}: {counts.get(s,0)}", style=None)
    #  Key Findings clustered (tone based on your example) :contentReference[oaicite:3]{index=3}
    doc.add_heading("2. Key Findings (clustered)", level=1)
    for grp in S:
        h = doc.add_heading(f"{grp['category']}  — {grp['count']} issues", level=2)
        doc.add_paragraph(f"Why this matters: {why_it_matters(grp['category'])}")
        doc.add_paragraph(f"What to do: {grp['action']}")
        # examples
        doc.add_paragraph("Examples:")
        for ex in grp["examples"]:
            doc.add_paragraph(f"• {ex['criterion']} — Page: {ex['page']} — Element: {ex['selector']}")
    # Next steps (based on example structure)
    doc.add_heading("3. Next Steps", level=1)
    doc.add_paragraph("Prioritise Critical/Serious issues first. Address contrast and labels next, then structure and mobile improvements.")
    # Save to in-memory bytes
    buf = io.BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf

def why_it_matters(category):
    lib = {
        "Page Structure and Headings": "Headings and landmarks help people using screen readers understand the page and find content quickly.",
        "Keyboard Navigation": "Some users rely on a keyboard, not a mouse. Keyboard access and visible focus are essential.",
        "Text and Colour Contrast": "Low contrast makes content hard to read for users with low vision or colour blindness.",
        "Images and Alt Text": "Alt text lets screen readers describe images to people who can’t see them.",
        "Forms and Labels": "Clear labels and announced errors help everyone complete forms successfully.",
        "Mobile Accessibility": "A large portion of users browse on phones; content and controls must work well on small screens.",
        "Screen Reader Experience": "Correct names/roles/states let assistive tech announce controls properly and avoid confusion."
    }
    return lib.get(category, "This area affects how easily people can understand and use your website.")

def build_client_statement_docx(results, org_name, contact_name, contact_email):
    """Client-facing accessibility statement (.docx), tone like your example. :contentReference[oaicite:4]{index=4}"""
    grouped = group_issues_plain(results)
    doc = Document()
    doc.core_properties.title = "Accessibility Statement"
    doc.add_heading("Accessibility Statement", level=0)
    doc.add_paragraph(f"Website: {results['site']}")
    doc.add_paragraph(f"Organisation: {org_name or urllib.parse.urlparse(results['site']).netloc}")
    doc.add_paragraph(f"Last Updated: {results['scanned_at']}")
    doc.add_paragraph("")
    doc.add_heading("Our Commitment", level=1)
    doc.add_paragraph("We’re committed to making our website accessible to as many users as possible, including people with disabilities. We aim to meet WCAG 2.2 Level AA and we’re improving the site over time.")
    doc.add_heading("Current Status", level=1)
    doc.add_paragraph("This website is partially compliant with WCAG 2.2 Level AA due to the areas for improvement listed below.")
    doc.add_heading("Areas for Improvement", level=1)
    for grp in grouped:
        doc.add_heading(grp["category"], level=2)
        doc.add_paragraph(f"Summary: {grp['count']} issues found. {plain_action_for(grp['category'])}")
    doc.add_heading("Planned Improvements", level=1)
    doc.add_paragraph("We’ll address the most impactful issues first (forms/labels, keyboard access, and contrast), then improve structure, mobile experience, and screen reader announcements as part of an ongoing roadmap.")
    doc.add_heading("Feedback and Contact", level=1)
    doc.add_paragraph(f"If you find accessibility barriers, need content in a different format, or want to share feedback, contact {contact_name or 'our team'} at {contact_email or 'info@example.com'}.")
    buf = io.BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf

# --------- Streamlit UI (same as original + two docx buttons)
st.set_page_config(page_title="Website Accessibility Checker (Client Files)", page_icon="✅", layout="wide")
st.title("Website Accessibility Checker")
st.caption("Identical scanner + client-friendly report/statement downloads.")

with st.sidebar:
    url = st.text_input("Start URL (include https://)", placeholder="https://example.com")
    max_pages = st.number_input("Max pages to scan", 1, 500, DEFAULT_MAX_PAGES)
    org_name = st.text_input("Organisation name", "")
    contact_name = st.text_input("Contact name", "Accessibility Lead")
    contact_email = st.text_input("Contact email", "accessibility@example.com")
    run_btn = st.button("Run accessibility scan", type="primary")

if run_btn:
    if not url or not url.startswith("http"):
        st.error("Please enter a valid URL starting with http or https.")
        st.stop()
    with st.spinner("Scanning…"):
        results = asyncio.run(scan_site(url, max_pages=int(max_pages)))

    # existing outputs
    df = to_dataframe(results)
    st.subheader("Summary")
    st.write(f"**Pages scanned:** {results.get('pages_scanned',0)}")
    st.write(f"**Total issues found:** {len(results['violations'])}")
    if not df.empty:
        st.dataframe(df, use_container_width=True)
        st.download_button("Download audit CSV", df.to_csv(index=False).encode("utf-8"),
                           file_name="a11y_audit.csv", mime="text/csv")
    else:
        st.success("No issues found.")

    st.divider()
    # On-screen statement (same as before)
    groups = []
    # quick grouping just for on-screen md
    for g in group_issues_plain(results):
        groups.append({"category": g["category"], "criterion": g["category"], "items":[
            {"page": ex["page"], "selector": ex["selector"], "summary": ex["description"], "impact": SEVERITY_MAP.get(ex["severity"],"Moderate")}
            for ex in g["examples"]
        ]})
    md = Template(STATEMENT_TEMPLATE).render(
        org_name=org_name or urllib.parse.urlparse(results["site"]).netloc,
        wcag_version=results["wcag_version"],
        scanned_at=results["scanned_at"],
        pages_scanned=results["pages_scanned"],
        groups=groups
    )
    st.header("Accessibility Statement (Preview)")
    st.markdown(md)

    st.divider()
    # NEW: client-friendly .docx downloads
    st.header("Client-friendly downloads")
    audit_doc = build_client_audit_docx(results, org_name)
    st.download_button("Download Client Accessibility Audit Report (.docx)",
                       data=audit_doc.getvalue(),
                       file_name="Client_Accessibility_Audit_Report.docx",
                       mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
    stmt_doc = build_client_statement_docx(results, org_name, contact_name, contact_email)
    st.download_button("Download Client Accessibility Statement (.docx)",
                       data=stmt_doc.getvalue(),
                       file_name="Client_Accessibility_Statement.docx",
                       mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document")

else:
    st.info("Enter a URL in the sidebar and click **Run accessibility scan**.")


